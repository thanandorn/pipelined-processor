//
// Module processorV2_lib.control.fsm
//
// Created:
//          by - Administrator.UNKNOWN (BIGBLUE)
//          at - 20:12:16 23/01/2005
//
// Generated by Mentor Graphics' HDL Designer(TM) 2004.1 (Build 41)
//

`resetall
`timescale 1ns/10ps
module control( 
   OpCode, 
   Reset, 
   SystemClk, 
   Zero, 
   ALUFunc, 
   Clk, 
   DMAddrSel, 
   DataInClk, 
   DataOutClk, 
   MemWt, 
   PCClk, 
   PCSource, 
   RdAddrSel, 
   RegWt, 
   WtDataSel
);


// Internal Declarations

input  [3:0] OpCode;
input        Reset;
input        SystemClk;
input        Zero;
output       ALUFunc;
output       Clk;
output       DMAddrSel;
output       DataInClk;
output       DataOutClk;
output       MemWt;
output       PCClk;
output       PCSource;
output       RdAddrSel;
output       RegWt;
output [1:0] WtDataSel;


wire [3:0] OpCode;
wire Reset;
wire SystemClk;
wire Zero;
reg ALUFunc;
reg Clk;
reg DMAddrSel;
reg DataInClk;
reg DataOutClk;
reg MemWt;
reg PCClk;
reg PCSource;
reg RdAddrSel;
reg RegWt;
reg [1:0] WtDataSel;
// Module Declarations
// State encoding
parameter [4:0] // pragma enum current_state_code
          ALUWrt    = 5'd0 ,
          LW        = 5'd1 ,
          LI        = 5'd2 ,
          SW        = 5'd3 ,
          MemWrt    = 5'd4 ,
          Add       = 5'd5 ,
          Rst       = 5'd6 ,
          InstRead  = 5'd7 ,
          Decode    = 5'd8 ,
          Sub       = 5'd9 ,
          PCInc     = 5'd10 ,
          Jump      = 5'd11 ,
          SourceSt1 = 5'd12 ,
          JNZ       = 5'd13 ,
          SourceSt0 = 5'd14 ,
          nop       = 5'd15 ,
          LWwrt     = 5'd16 ,
          LIWrt     = 5'd17 ,
          RegRdClk2 = 5'd18 ,
          RegRdClk4 = 5'd19 ,
          RegRdClk3 = 5'd20 ,
          LWA       = 5'd21 ,
          LWAwrt    = 5'd22 ,
          SWA       = 5'd23 ,
          SWAMemWrt = 5'd24 ,
          RegRdClk5 = 5'd25 ,
          LA        = 5'd26 ,
          s1        = 5'd27 ,
          Inp       = 5'd28 ,
          s0        = 5'd29 ,
          Outp      = 5'd30 ,
          LWAwrt2   = 5'd31 ;

reg [4:0] /* pragma enum current_state_code */ current_state, next_state ;
// pragma state_vector current_state

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always  @(
   OpCode or 
   Zero or 
   current_state) 
begin
   case (current_state)
      ALUWrt:

            next_state = PCInc;

      LW:

            next_state = LWwrt;

      LI:

            next_state = LIWrt;

      SW:

            next_state = MemWrt;

      MemWrt:

            next_state = PCInc;

      Add:

            next_state = RegRdClk2;

      Rst:

            next_state = InstRead;

      InstRead:

            next_state = Decode;

      Decode:
      begin
         next_state = Decode;
         if ( OpCode == 4'b0001)
            next_state = LW;
         if ( OpCode == 4'b0010)
            next_state = LI;
         if (OpCode == 4'b0011)
            next_state = SW;
         if ( OpCode == 4'b0100)
            next_state = Add;
         if ( OpCode == 4'b0101)
            next_state = Sub;
         if ( OpCode == 4'b0110)
            next_state = Jump;
         if ( OpCode == 4'b0111)
            next_state = JNZ;
         if (OpCode == 4'b 0000)
            next_state = nop;
         if (OpCode ==4'b1000)
            next_state = LWA;
         if (OpCode==4'b1001)
            next_state = SWA;
         if (OpCode==4'b1010)
            next_state = LA;
         if (OpCode==4'b1011)
            next_state = Inp;
         if (OpCode ==4'b1100)
            next_state = Outp;
      end
      Sub:

            next_state = RegRdClk3;

      PCInc:

            next_state = InstRead;

      Jump:

            next_state = PCInc;

      SourceSt1:

            next_state = PCInc;

      JNZ:

            next_state = RegRdClk4;

      SourceSt0:

            next_state = PCInc;

      nop:

            next_state = PCInc;

      LWwrt:

            next_state = PCInc;

      LIWrt:

            next_state = PCInc;

      RegRdClk2:

            next_state = ALUWrt;

      RegRdClk4:
         if (Zero == 1)
            next_state = SourceSt1;
         else if (Zero ==0)
            next_state = SourceSt0;
         else
            next_state = RegRdClk4;
      RegRdClk3:

            next_state = ALUWrt;

      LWA:

            next_state = LWAwrt;

      LWAwrt:

            next_state = LWAwrt2;

      SWA:

            next_state = RegRdClk5;

      SWAMemWrt:

            next_state = PCInc;

      RegRdClk5:

            next_state = SWAMemWrt;

      LA:

            next_state = s1;

      s1:

            next_state = PCInc;

      Inp:

            next_state = s0;

      s0:

            next_state = PCInc;

      Outp:

            next_state = PCInc;

      LWAwrt2:

            next_state = PCInc;

      default: begin
         next_state = Rst;
      end
   endcase

end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always  @(
   current_state) 
begin
   // Default Assignment
   ALUFunc = 0;
   Clk = 0;
   DMAddrSel = 0;
   DataInClk = 0;
   DataOutClk = 0;
   MemWt = 0;
   PCClk = 0;
   PCSource = 0;
   RdAddrSel = 0;
   RegWt = 0;
   WtDataSel = 0;
   // Default Assignment To Internals

   // Combined Actions
   case (current_state)
      ALUWrt: begin
          RegWt = 1 ;
         WtDataSel = 2'b00;
      end
      LW: begin
         WtDataSel = 2'b10 ;
      end
      LI: begin
          WtDataSel =2'b 01;
      end
      SW: begin
         Clk = 1;
      end
      MemWrt: begin
          MemWt = 1 ;
      end
      Add: begin
         ALUFunc = 0;
         WtDataSel = 2'b00;
         RdAddrSel = 1; 
      end
      Rst: begin
          Clk = 0;
      end
      InstRead: begin
         Clk = 1;
      end
      Sub: begin
         ALUFunc = 1;
         WtDataSel = 2'b00;
         RdAddrSel = 1; 
      end
      PCInc: begin
          PCClk = 1 ;
      end
      Jump: begin
          PCSource = 1 ;
      end
      SourceSt1: begin
         PCSource = 1 ;
      end
      JNZ: begin
         RdAddrSel = 1;
      end
      SourceSt0: begin
          PCSource = 0 ;
      end
      LWwrt: begin
         WtDataSel = 2'b10;
         RegWt = 1;
      end
      LIWrt: begin
         WtDataSel = 2'b01;
         RegWt = 1;
      end
      RegRdClk2: begin
         Clk = 1;
         ALUFunc = 0;
         WtDataSel = 2'b00;
         RdAddrSel = 1; 
      end
      RegRdClk4: begin
         Clk = 1;
         RdAddrSel = 1;
      end
      RegRdClk3: begin
         Clk = 1;
         ALUFunc = 1;
         WtDataSel = 2'b00;
         RdAddrSel = 1; 
      end
      LWA: begin
         DMAddrSel =1'b1 ;
      end
      LWAwrt: begin
         WtDataSel = 2'b10 ;
         DMAddrSel =1'b1 ;
         RegWt = 1;
         Clk = 1;
      end
      SWAMemWrt: begin
         MemWt = 1;
         DMAddrSel=1;
      end
      RegRdClk5: begin
         DMAddrSel =1'b1 ;
         Clk=1;
      end
      LA: begin
          WtDataSel =2'b 01;
      end
      s1: begin
         WtDataSel = 2'b01;
         RegWt = 1;
      end
      Inp: begin
         WtDataSel =2'b11;
         RdAddrSel = 1;
         DataInClk=1;
      end
      s0: begin
         WtDataSel = 2'b11;
         RdAddrSel = 1;
         RegWt = 1;
      end
      Outp: begin
         DataOutClk=1 ;
      end
      LWAwrt2: begin
         WtDataSel = 2'b10 ;
         RegWt = 1;
         DMAddrSel =1'b1;
      end
   endcase


end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge SystemClk or posedge Reset
) begin
   if (Reset) begin
      current_state <= Rst;
      // Reset Values
   end
   else
   begin
      current_state <= next_state;
      // Default Assignment To Internals
   end
end // Clocked Block

// Concurrent Statements
endmodule // control

